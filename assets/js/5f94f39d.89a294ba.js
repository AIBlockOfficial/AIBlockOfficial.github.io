"use strict";(self.webpackChunkaiblock_dev=self.webpackChunkaiblock_dev||[]).push([[7087],{15680:(e,t,n)=>{n.d(t,{xA:()=>d,yg:()=>m});var o=n(96540);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function a(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);t&&(o=o.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,o)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?a(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):a(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,o,r=function(e,t){if(null==e)return{};var n,o,r={},a=Object.keys(e);for(o=0;o<a.length;o++)n=a[o],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(o=0;o<a.length;o++)n=a[o],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var l=o.createContext({}),c=function(e){var t=o.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},d=function(e){var t=c(e.components);return o.createElement(l.Provider,{value:t},e.children)},u="mdxType",g={inlineCode:"code",wrapper:function(e){var t=e.children;return o.createElement(o.Fragment,{},t)}},p=o.forwardRef((function(e,t){var n=e.components,r=e.mdxType,a=e.originalType,l=e.parentName,d=s(e,["components","mdxType","originalType","parentName"]),u=c(n),p=r,m=u["".concat(l,".").concat(p)]||u[p]||g[p]||a;return n?o.createElement(m,i(i({ref:t},d),{},{components:n})):o.createElement(m,i({ref:t},d))}));function m(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var a=n.length,i=new Array(a);i[0]=p;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s[u]="string"==typeof e?e:r,i[1]=s;for(var c=2;c<a;c++)i[c]=n[c];return o.createElement.apply(null,i)}return o.createElement.apply(null,n)}p.displayName="MDXCreateElement"},24936:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>i,default:()=>g,frontMatter:()=>a,metadata:()=>s,toc:()=>c});var o=n(58168),r=(n(96540),n(15680));const a={$title:"AIBlock Storage Node",description:"Learn about AIBlock's Storage node type",sidebar_label:"Storage Node",sidebar_position:3,hide_title:!0,tags:["deep dive documentation","aiblock network"]},i="Storage Node",s={unversionedId:"network-wiki/storage-node",id:"network-wiki/storage-node",title:"Storage Node",description:"Learn about AIBlock's Storage node type",source:"@site/docs/network-wiki/storage-node.mdx",sourceDirName:"network-wiki",slug:"/network-wiki/storage-node",permalink:"/docs/network-wiki/storage-node",draft:!1,tags:[{label:"deep dive documentation",permalink:"/docs/tags/deep-dive-documentation"},{label:"aiblock network",permalink:"/docs/tags/aiblock-network"}],version:"current",sidebarPosition:3,frontMatter:{$title:"AIBlock Storage Node",description:"Learn about AIBlock's Storage node type",sidebar_label:"Storage Node",sidebar_position:3,hide_title:!0,tags:["deep dive documentation","aiblock network"]},sidebar:"docsSidebar",previous:{title:"Miner Node",permalink:"/docs/network-wiki/miner-node"},next:{title:"UNiCORNs",permalink:"/docs/network-wiki/unicorns"}},l={},c=[{value:"Storage Node Structure",id:"storage-node-structure",level:2},{value:"Receiving Blocks",id:"receiving-blocks",level:2},{value:"Receiving UNiCORN Values",id:"receiving-unicorn-values",level:2},{value:"Receiving DRUIDs",id:"receiving-druids",level:2},{value:"Storage Node Consensus",id:"storage-node-consensus",level:2}],d={toc:c},u="wrapper";function g(e){let{components:t,...n}=e;return(0,r.yg)(u,(0,o.A)({},d,n,{components:t,mdxType:"MDXLayout"}),(0,r.yg)("h1",{id:"storage-node"},"Storage Node"),(0,r.yg)("p",null,"The Storage node has a singular responsibility: storing the complete blockchain history. Though seemingly straightforward, this task involves various components within the AIBlock system, detailed below."),(0,r.yg)("h2",{id:"storage-node-structure"},"Storage Node Structure"),(0,r.yg)("p",null,"The Storage node consists of two main components:"),(0,r.yg)("ul",null,(0,r.yg)("li",{parentName:"ul"},(0,r.yg)("strong",{parentName:"li"},(0,r.yg)("inlineCode",{parentName:"strong"},"StorageNode"),":")," Data structure."),(0,r.yg)("li",{parentName:"ul"},(0,r.yg)("strong",{parentName:"li"},(0,r.yg)("inlineCode",{parentName:"strong"},"StorageInterface"),":")," A trait defining many externally-facing methods.")),(0,r.yg)("p",null,"A limited number of Storage nodes, currently under direct management, handle the blockchain's storage. Public miners or users may request to become new Storage nodes, but it's not mandatory for system operation."),(0,r.yg)("p",null,"The ring of Storage nodes operates collectively under ",(0,r.yg)("a",{parentName:"p",href:"https://raft.github.io/"},"RAFT consensus"),", receiving blocks from Mempool nodes and ensuring consistency among transactions."),(0,r.yg)("h2",{id:"receiving-blocks"},"Receiving Blocks"),(0,r.yg)("p",null,"The primary role of the Storage node is receiving blocks through the ",(0,r.yg)("inlineCode",{parentName:"p"},"receive_block")," method, which involves:"),(0,r.yg)("ul",null,(0,r.yg)("li",{parentName:"ul"},"Comparing block IDs against received blocks."),(0,r.yg)("li",{parentName:"ul"},"Matching transactions between blocks with the same ID, flagging non-matching blocks as invalid."),(0,r.yg)("li",{parentName:"ul"},"Performing RAFT consensus with peer Storage nodes."),(0,r.yg)("li",{parentName:"ul"},"Saving all valid blocks to the database.")),(0,r.yg)("h2",{id:"receiving-unicorn-values"},"Receiving UNiCORN Values"),(0,r.yg)("p",null,"To validate the correctness of blocks, AIBlock's blockchain utilizes a special value called ",(0,r.yg)("a",{parentName:"p",href:"unicorns"},"UNiCORN")," in combination with a block hash. The Storage nodes handle the preservation of UNiCORN values through the ",(0,r.yg)("inlineCode",{parentName:"p"},"receive_unicorn_table")," method:"),(0,r.yg)("ul",null,(0,r.yg)("li",{parentName:"ul"},"Using the UNiCORN's evaluation function to prove the validity of inputs for the provided UNiCORN value."),(0,r.yg)("li",{parentName:"ul"},"Performing RAFT consensus with peer Storage nodes."),(0,r.yg)("li",{parentName:"ul"},"Saving the block to the database.")),(0,r.yg)("h2",{id:"receiving-druids"},"Receiving DRUIDs"),(0,r.yg)("p",null,"Recording the history of ",(0,r.yg)("a",{parentName:"p",href:"https://medium.com/the-zendesk/druids-how-to-easily-trade-on-blockchains-without-smart-contracts-ac1af79a34df"},"DRUIDs")," is crucial for auditing asset trades. The Storage nodes, via the ",(0,r.yg)("inlineCode",{parentName:"p"},"receive_druids")," method, handle the storage of DRUIDs by saving them directly to disk. No validation requirement is currently planned for these saves."),(0,r.yg)("p",null,"Separate storage of DRUID histories is a future plan, and users can manually construct these histories by searching for DRUID-related transactions within the same block."),(0,r.yg)("h2",{id:"storage-node-consensus"},"Storage Node Consensus"),(0,r.yg)("p",null,"For a new block to be successfully added to the blockchain, it must be found valid and replicated across all Storage nodes"))}g.isMDXComponent=!0}}]);