"use strict";(self.webpackChunkaiblock_dev=self.webpackChunkaiblock_dev||[]).push([[5693],{15680:(e,t,n)=>{n.d(t,{xA:()=>p,yg:()=>y});var r=n(96540);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function a(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?a(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):a(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,r,i=function(e,t){if(null==e)return{};var n,r,i={},a=Object.keys(e);for(r=0;r<a.length;r++)n=a[r],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(r=0;r<a.length;r++)n=a[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var u=r.createContext({}),l=function(e){var t=r.useContext(u),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},p=function(e){var t=l(e.components);return r.createElement(u.Provider,{value:t},e.children)},c="mdxType",d={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},g=r.forwardRef((function(e,t){var n=e.components,i=e.mdxType,a=e.originalType,u=e.parentName,p=s(e,["components","mdxType","originalType","parentName"]),c=l(n),g=i,y=c["".concat(u,".").concat(g)]||c[g]||d[g]||a;return n?r.createElement(y,o(o({ref:t},p),{},{components:n})):r.createElement(y,o({ref:t},p))}));function y(e,t){var n=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var a=n.length,o=new Array(a);o[0]=g;var s={};for(var u in t)hasOwnProperty.call(t,u)&&(s[u]=t[u]);s.originalType=e,s[c]="string"==typeof e?e:i,o[1]=s;for(var l=2;l<a;l++)o[l]=n[l];return r.createElement.apply(null,o)}return r.createElement.apply(null,n)}g.displayName="MDXCreateElement"},39807:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>u,contentTitle:()=>o,default:()=>d,frontMatter:()=>a,metadata:()=>s,toc:()=>l});var r=n(58168),i=(n(96540),n(15680));const a={title:"AIBlock Transactions",description:"Learn about AIBlock's Transactions",sidebar_label:"Transactions",sidebar_position:5,hide_title:!0,tags:["deep dive documentation","aiblock network"]},o="Transactions",s={unversionedId:"network-wiki/transactions",id:"network-wiki/transactions",title:"AIBlock Transactions",description:"Learn about AIBlock's Transactions",source:"@site/docs/network-wiki/transactions.mdx",sourceDirName:"network-wiki",slug:"/network-wiki/transactions",permalink:"/docs/network-wiki/transactions",draft:!1,tags:[{label:"deep dive documentation",permalink:"/docs/tags/deep-dive-documentation"},{label:"aiblock network",permalink:"/docs/tags/aiblock-network"}],version:"current",sidebarPosition:5,frontMatter:{title:"AIBlock Transactions",description:"Learn about AIBlock's Transactions",sidebar_label:"Transactions",sidebar_position:5,hide_title:!0,tags:["deep dive documentation","aiblock network"]},sidebar:"docsSidebar",previous:{title:"UNiCORNs",permalink:"/docs/network-wiki/unicorns"},next:{title:"Block Mining",permalink:"/docs/network-wiki/block-mining"}},u={},l=[{value:"Structure",id:"structure",level:2},{value:"Inputs",id:"inputs",level:2},{value:"Outputs",id:"outputs",level:2},{value:"Signing",id:"signing",level:2}],p={toc:l},c="wrapper";function d(e){let{components:t,...n}=e;return(0,i.yg)(c,(0,r.A)({},p,n,{components:t,mdxType:"MDXLayout"}),(0,i.yg)("h1",{id:"transactions"},"Transactions"),(0,i.yg)("p",null,"Transactions in the AIBlock system are structured similarly to those found in Bitcoin. They consist primarily of a reference to a previous spendable amount on the blockchain (for AIBlock, this can be tokens or items (data assets) ) and a reference to an address to send the spendable amount to. To accomplish this, the spender is required to verify that they are the original owner of the spendable amount through public key signature schemes."),(0,i.yg)("h2",{id:"structure"},"Structure"),(0,i.yg)("p",null,"In the codebase, a transaction is structured as follows:"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-rust"},"pub struct Transaction {\n    pub inputs: Vec<TxIn>,\n    pub outputs: Vec<TxOut>,\n    pub version: usize,\n    pub druid_info: Option<DdeValues>,\n}\n")),(0,i.yg)("p",null,"The attributes we care about for ownership verification are ",(0,i.yg)("inlineCode",{parentName:"p"},"inputs")," and ",(0,i.yg)("inlineCode",{parentName:"p"},"outputs"),", corresponding to the ",(0,i.yg)("inlineCode",{parentName:"p"},"TxIn")," and ",(0,i.yg)("inlineCode",{parentName:"p"},"TxOut")," data structures respectively."),(0,i.yg)("h2",{id:"inputs"},"Inputs"),(0,i.yg)("p",null,"The inputs to a transaction are codified in the ",(0,i.yg)("inlineCode",{parentName:"p"},"TxIn")," data structure:"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-rust"},"pub struct TxIn {\n    pub previous_out: Option<OutPoint>,\n    pub script_signature: Script,\n}\n")),(0,i.yg)("p",null," where the ",(0,i.yg)("inlineCode",{parentName:"p"},"OutPoint")," referenced in ",(0,i.yg)("inlineCode",{parentName:"p"},"previous_out"),":"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-rust"},"pub struct OutPoint {\n    pub t_hash: String,\n    pub n: i32,\n}\n")),(0,i.yg)("p",null,(0,i.yg)("inlineCode",{parentName:"p"},"OutPoint")," has a ",(0,i.yg)("inlineCode",{parentName:"p"},"t_hash")," corresponding to the hash of the previous spendable transaction in the blockchain. Within the ",(0,i.yg)("inlineCode",{parentName:"p"},"script_signature")," attribute, we find a transaction execution script that defines how the spendable amount should actually be spent. Included in all ",(0,i.yg)("inlineCode",{parentName:"p"},"script_signature")," entries is at least one signature which matches the public key of the spendable transaction already in the blockchain."),(0,i.yg)("h2",{id:"outputs"},"Outputs"),(0,i.yg)("p",null,"The outputs of a transaction are codified in the ",(0,i.yg)("inlineCode",{parentName:"p"},"TxOut")," data structure:"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-rust"},"pub struct TxOut {\n    pub value: Asset,\n    pub locktime: u64,\n    pub drs_block_hash: Option<String>,\n    pub script_public_key: Option<String>,\n}\n")),(0,i.yg)("p",null,"Here we'll focus on the ",(0,i.yg)("inlineCode",{parentName:"p"},"script_public_key"),", which is the public key that the owner of the transaction needs to use and sign with in order to spend the amount in the future."),(0,i.yg)("h2",{id:"signing"},"Signing"),(0,i.yg)("p",null,"In the AIBlock system, to tie the ",(0,i.yg)("inlineCode",{parentName:"p"},"TxIn")," of the current transaction to the ",(0,i.yg)("inlineCode",{parentName:"p"},"TxOut")," of the previous one, the user needs to sign the ",(0,i.yg)("strong",{parentName:"p"},"hash of the ",(0,i.yg)("inlineCode",{parentName:"strong"},"OutPoint"))," referencing that ",(0,i.yg)("inlineCode",{parentName:"p"},"TxOut"),". This ensures that spending a ",(0,i.yg)("inlineCode",{parentName:"p"},"TxOut")," amount is impossible without:"),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("strong",{parentName:"li"},"(A)")," The ",(0,i.yg)("inlineCode",{parentName:"li"},"OutPoint")," referencing a specific ",(0,i.yg)("inlineCode",{parentName:"li"},"TxOut")),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("strong",{parentName:"li"},"(B)")," The user having the private key corresponding to the ",(0,i.yg)("inlineCode",{parentName:"li"},"TxOut"),"'s public key"),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("strong",{parentName:"li"},"(C)")," Being able to sign with the private key to on-spend the tokens")))}d.isMDXComponent=!0}}]);